package com.hacktics.diviner.analyze;

import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.TimeZone;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.httpclient.URIException;
import org.parosproxy.paros.db.RecordHistory;
import org.parosproxy.paros.network.HtmlParameter;
import org.parosproxy.paros.network.HttpMessage;
import org.parosproxy.paros.network.HttpRequestHeader;

import com.hacktics.diviner.constants.DivinerFlags;
import com.hacktics.diviner.csrf.CsrfToken;
import com.hacktics.diviner.database.DivinerRecordParam;
import com.hacktics.diviner.database.DivinerTableFlow;
import com.hacktics.diviner.diffutil.GetResponsesSimilarity;
import com.hacktics.diviner.diffutil.Response_Diffs;
import com.hacktics.diviner.diffutil.Response_Diffs.Diff;
import com.hacktics.diviner.diffutil.Response_Manager;
import com.hacktics.diviner.diffutil.TokenLocations;
import com.hacktics.diviner.diffutil.TokenWrapper;
import com.hacktics.diviner.diffutil.UnRelevantInfo;
import com.hacktics.diviner.diffutil.UnRelevantTag;
import com.hacktics.diviner.gui.OUTPUT_TYPE;
import com.hacktics.diviner.gui.ParameterEffect;
import com.hacktics.diviner.gui.RESULT_TYPE;
import com.hacktics.diviner.gui.scanwizard.DiffCheckBox;
import com.hacktics.diviner.gui.scanwizard.ExceptionsConfigDialog;
import com.hacktics.diviner.gui.scanwizard.ScanWizard;
import com.hacktics.diviner.zapDB.ZapHistoryDB;

/**
 * 
 * @authors Eran Tamari, Shay Chen, Alex Mor
 *
 */
public abstract class AbstractAnalyzer {

	public static final String SET_COOKIE = "Set-Cookie";
	protected boolean runOnlyOnePlugin; // Database analyzer uses this flag to run only one plugin
	protected RESULT_TYPE selectedPlugin;
	protected boolean isFound = false;
	protected boolean isTokenReflected = false;
	protected boolean isException = false;
	protected boolean isDiff = false;
	protected static final String POST = "POST";
	private static boolean FULL_HISTORY = true;
	protected static final boolean DBWRITE = true;
	protected static final boolean SOURCE_AND_TARGET_IDENTICAL = true;
	protected static final boolean SKIP_SOURCE = true;
	protected static final boolean FOUND = true;
	protected boolean isSourceTargetIdentical;
	protected SCENARIO_MODE scenario;
	protected HISTORY_MODE histMode;
	protected String token;
	protected TOKEN_TYPE tokenType;
	protected boolean isTokenAppendMode;
	protected boolean isIntanceOfDbAnalyzer = false;
	protected static final int WRITE_DB_FLOW = -2;
	protected static final int DONT_WRITE_FLOW = -1;	//There are cases where we need to avoid writing flows
	private int diffInCleanResponse;

	/**
	 * This method is used to access the source page, alongside the test input,
	 * and return any cookies that were generated by the response. 
	 * 
	 * @param sourceHID the id of the source entry point in ZAP DB
	 * @param targetHID the id of the target entry point in ZAP DB
	 * @param historyFlag an ENUM flag that signifies whether or not to access the history
	 * @param sessionCookie contains the session id and other cookie parameters
	 * @param param the parameter to test
	 * @param token the random token to send in the parameter 
	 * @param isSourceTargetIdentical - if the flag is true - search the token in the source response instead of the target
	 * @param isDBWrite if the flag is true - if found -the result is written to the DB
	 * @return TreeSet the list of new session cookies, or null if none were returned
	 */
	protected TreeSet<HtmlParameter> sourcePageAccess(RecordHistory source,RecordHistory target, HISTORY_MODE historyFlag, TreeSet<HtmlParameter> sessionCookie, HtmlParameter param, String token,
			FlowDocumentation flow, boolean isSourceTargetIdentical, boolean isDBWrite, boolean isTokenAppendMode){

		this.isTokenAppendMode = isTokenAppendMode;
		HttpMessage sourceMsg = source.getHttpMessage();
		//returned value, potential new cookies from response
		TreeSet<HtmlParameter> newSessionCookies = null; 
		//Get ONLY the HTTP request of the source entry point
		HttpMessage sourceMsgClone = sourceMsg.cloneRequest();

		this.isSourceTargetIdentical = isSourceTargetIdentical;
		//TODO: perform QA on the sendNotAffectingRequestUntilPage method
		sendHistory(historyFlag, sessionCookie, source, target);
		//update the cookie and param in the method
		sourceMsgClone.setCookieParams(sessionCookie);
		setTokenInRequest(sourceMsgClone, param, token);


		//send the actual updated request
		//		AnalyzerUtils.setCsrfTokens(sourceMsgClone);
		RequestSender.send(sourceMsgClone);

		//if new cookies were returned, update the calling functions by returning them
		if (sourceMsgClone.getResponseHeader().getHeader(SET_COOKIE) != null) {
			newSessionCookies = sourceMsgClone.getResponseHeader().getCookieParams();	
		}
		//Check for Mirror parameters
		if (isSourceTargetIdentical) {

			FlowDocumentation newSessionFlow = flow.clone();
			newSessionFlow.addResponseDocumentation(token, sessionCookie, newSessionCookies, sourceMsgClone.getResponseHeader().getStatusCode()+"", "sourcePageAccess"); //response code is unknown here
			//isTokenFound(sourceMsgClone, sourceMsgClone, token, param.getName(), sourceMsgClone.getParamNames(), isDBWrite);
			if (tokenType == null) {
				//TODO: Throw Exception
				System.out.println("Null Token");
			}
			responseAnalysis(source, source, sourceMsgClone, token, param,  AnalyzerUtils.getMsgParams(sourceMsg), newSessionFlow, isDBWrite);
		}
		return newSessionCookies;
	} //end of method

	protected void sendHistory(HISTORY_MODE historyFlag, TreeSet<HtmlParameter> sessionCookie, RecordHistory source, RecordHistory target) {
		switch (historyFlag) {
		case NO_HISTORY:
			break;
		case PARTIAL_HISTORY:
			AnalyzerUtils.sendNotAffectingRequestUntilPage(source, target, sessionCookie, !FULL_HISTORY, ScanWizard.getHistoryLimit());
			break;
		case FULL_HISTORY:
			AnalyzerUtils.sendNotAffectingRequestUntilPage(source, target, sessionCookie, FULL_HISTORY, ScanWizard.getHistoryLimit());
			break;	
		case CUSTOM_HISTORY:
			AnalyzerUtils.sendNotAffectingRequestUntilPage(source, target, sessionCookie, FULL_HISTORY, ScanWizard.getHistoryLimit());
			break;
		}
	}

	protected void targetAccess(RecordHistory source, RecordHistory target, TreeSet<HtmlParameter> session, String token, HtmlParameter param, FlowDocumentation flow, boolean isDBWrite) {

		HttpMessage sourceMsg = source.getHttpMessage();
		HttpMessage targetMsg = target.getHttpMessage();

		HttpMessage targetMsgClone = targetMsg.cloneRequest();

		targetMsgClone.setCookieParams(session);

		//		AnalyzerUtils.setCsrfTokens(targetMsgClone);
		RequestSender.send(targetMsgClone);

		FlowDocumentation newSessionFlow = flow.clone();
		newSessionFlow.addResponseDocumentation(token, session, null, targetMsgClone.getResponseHeader().getStatusCode()+"", "targetAccess"); //response code is unknown here
		if (tokenType == null) {
			//TODO: Throw Exception
			System.out.println("Null Token");
		}
		responseAnalysis(source, target, targetMsgClone, token, param, AnalyzerUtils.getMsgParams(sourceMsg), newSessionFlow, isDBWrite); 
	}

	private void setTokenInRequest(HttpMessage msg, HtmlParameter param, String token) {
		switch (param.getType()) {

		case form:
			AnalyzerUtils.setParameterPostRequest(msg, param.getName(), token);
			break;

		case url:
			AnalyzerUtils.setParameterGetRequest(msg, param.getName(), token);
			break;
		}
	}

	protected String generateToken(String paramValue) {
		String token = "";

		switch (tokenType) {

		case RANDOM_VALUE:
			token = AnalyzerUtils.getToken(paramValue, isTokenAppendMode);
			break;

		case VALID_VALUE:
			break;

		case INVALID_VALUE:
			token = AnalyzerUtils.getToken(paramValue, isTokenAppendMode) + ExceptionsConfigDialog.getConcatenatedPayloads();
			break;

		}
		return token;
	}

	protected boolean responseAnalysis(RecordHistory source, RecordHistory target, HttpMessage outputPage, String token,
			HtmlParameter suspectParam, TreeSet<HtmlParameter> params, FlowDocumentation flow, boolean writeMode)	{

		diffInCleanResponse = 0; //Symbolizes 100 similarity - no diff 

		//Reflection plugin
		//detect direct/indirect input reflection scenarios
		if ((runOnlyOnePlugin && selectedPlugin.equals(RESULT_TYPE.REFLECTION)) ||(! runOnlyOnePlugin && Plugins.isReflectionEnabled())) {
			isTokenFound(source, target, outputPage, token, suspectParam, params, flow, writeMode);
		}
		
		boolean flowTypeLogin = false;
		if (flow.getResponseListSize()>=2) {
			flowTypeLogin = flow.getResponseDocumentation(flow.getResponseListSize()-2).getType().contains("NEW_SESSION");
		}
		
		//Diff plugin
		//calculate the diff of the current response compared to the original response in history (clean diff - after removal of constantly-changing values and user configured patterns
		if (((runOnlyOnePlugin && selectedPlugin.equals(RESULT_TYPE.DIFF)) ||(! runOnlyOnePlugin && Plugins.isDiffEnabled())) && flowTypeLogin) {
			diffInCleanResponse = (100 - getSimilarity(source, target, outputPage, token, suspectParam, params, flow, writeMode));
			
			//verify this is really a diff or normal application behaviour:
			//access source page and then target page with original parameters, but with the new outpage session cookies
			if (diffInCleanResponse > 0) {
				isDiff = true;
				
				HttpMessage sourceDiff = source.getHttpMessage().cloneRequest();
				HttpMessage targetDiff = target.getHttpMessage().cloneRequest();
				
				sourceDiff.setCookieParams(outputPage.getResponseHeader().getCookieParams());
				RequestSender.send(sourceDiff);
				
				//update cookies received from the source page response
				targetDiff.setCookieParams(sourceDiff.getResponseHeader().getCookieParams());
				RequestSender.send(targetDiff);

				int diffVerify = (100 - getSimilarity(source, target, targetDiff, token, suspectParam, params, flow, false));
				
				//if diffs are the same - not a diff
				if (diffVerify==diffInCleanResponse) {
					isDiff = false;
					//diffInCleanResponse = 0;
					
				}
			}
		}

		//Exception plugin 
		//TODO: test only when payloads are sent 
		if ((runOnlyOnePlugin && selectedPlugin.equals(RESULT_TYPE.EXCEPTION)) ||(! runOnlyOnePlugin && Plugins.isExceptionEnabled())) {
			isException(source, target, outputPage, token, suspectParam, params, flow, writeMode);
		}

		//Parameter has an interesting effect
		if (isTokenReflected) {
			writeToDB(source, target, outputPage, token, suspectParam, params, flow, writeMode, RESULT_TYPE.REFLECTION);
			isFound = true;
		}
		if ((isDiff) && (diffInCleanResponse>0)) {
			writeToDB(source, target, outputPage, token, suspectParam, params, flow, writeMode, RESULT_TYPE.DIFF);
			isFound = true;
		}
		if (isException) {
			writeToDB(source, target, outputPage, token, suspectParam, params, flow, writeMode, RESULT_TYPE.EXCEPTION);
			isFound = true;
		}


		return isFound;
	}

	private void isException(RecordHistory source, RecordHistory target, HttpMessage outputPage, String token,
			HtmlParameter suspectParam, TreeSet<HtmlParameter> params, FlowDocumentation flow, boolean writeMode) {

		for (String errorStr : ExceptionsConfigDialog.getErrorsList()) {

			if (outputPage.getResponseBody().toString().toLowerCase().contains(errorStr.toLowerCase()) || outputPage.getResponseHeader().getStatusCode() == 500) {
				isException = true;
				break;
			}
		}
	}

	/*
	 * This method calculates the similarity between two responses, while removing as many accuracy barriers as possible.
	 *
	 * The similarity of responses can be affected by several factors that are not related to the actual differentiation/similarity,
	 * including various functional tokens (viewstate, anticsrf tokens, etc), varying values (date/time in response, random values, etc)
	 * and direct/indirect input values that are reflected in the response.
	 * Before calculating the similarity of two responses, we attempt to get rid of as many accuracy barriers as possible, and then calculate the similarity. 
	 */
	private int getSimilarity(RecordHistory source, RecordHistory target, HttpMessage outputPage, String token,
			HtmlParameter suspectParam, TreeSet<HtmlParameter> params, FlowDocumentation flow, boolean writeMode) {

		int similarity = 100;
		//isDiff = false;

		List<String> removeTagList = new ArrayList<String>();
		List<UnRelevantTag> diffTagList = new ArrayList<UnRelevantTag>();
		//List<UnRelevantTag> reflectedTagList = new ArrayList<UnRelevantTag>();

		String cleanOriginalResponse;
		String cleanCurrentResponse;

		for (CsrfToken csrfToken : AnalyzerUtils.getCsrfTokens()) {
			removeTagList.add(csrfToken.getName());
		}

		for (DiffCheckBox selectedDiff : AnalyzerUtils.getDiffsList()) {
			Diff diff = selectedDiff.getDiff();
			UnRelevantTag tag = new UnRelevantTag(diff.start, diff.between, diff.end);
			diffTagList.add(tag);
		}
	
		if(DivinerFlags.DEBUG_FLAG == true) {
			System.out.println("\nRemoving " + removeTagList.size() +  " user defined tags and " + diffTagList.size() + " automatically detected varying patterns from the response \n");
		}

		ArrayList<String> originalResponses = new ArrayList<>();
		originalResponses.add(target.getHttpMessage().getResponseBody().toString());	//Response from ZAP

		cleanOriginalResponse = UnRelevantInfo.removeUnRelevantData(target.getHttpMessage().getResponseBody().toString(), diffTagList, removeTagList); //remove from history response
		cleanCurrentResponse = UnRelevantInfo.removeUnRelevantData(outputPage.getResponseBody().toString(), diffTagList, removeTagList); //remove from current response

		//we need to remove the original reflected value prior to the diff comparison, but since the original value 
		//might be a short and trivial value (such as "12") that may appear in the response regardless of reflection,
		//we need to identify when it is reflected and when it is constant.
		//in order to accomplish that, we use the random token reflections to locate the relevant reflection positions in the response,
		//and remove the original reflected value from these specific locations in the history response, prior to comparison.

		//count the number of instances
		int tokenReflectionCount = TokenLocations.numberOfTokenInstances(cleanCurrentResponse,token);


		if(DivinerFlags.DEBUG_FLAG == true && tokenReflectionCount>0) {
			int originalValueReflectionCount = TokenLocations.numberOfTokenInstances(cleanOriginalResponse,/*get the original parameter value*/suspectParam.getValue()); //required only for debugging
			System.out.println("token reflection removal for request: " + source.getHistoryId());
			System.out.println("token reflection count: " + tokenReflectionCount);
			System.out.println( "original parameter name: " + suspectParam.getName() + " original parameter value: " + suspectParam.getValue());
			System.out.println("original reflected value count: " + originalValueReflectionCount);
		}

		//if there is a reflection behavior in our current response
		if(tokenReflectionCount > 0) {
			//get the token locations array from the current response
			ArrayList<TokenWrapper> tokenInstancesInResponse; 
			tokenInstancesInResponse = TokenLocations.tokenWrapperInstances(cleanCurrentResponse, token);

			//replace the token value in the location array with the original history value
			for(TokenWrapper cell: tokenInstancesInResponse) {
				cell.setTokenStr(suspectParam.getValue());
			}

			//remove the history-original reflected value from the original history response - according to the pattern and number of the random reflected value
			cleanOriginalResponse = TokenLocations.removeTokenInstances(tokenInstancesInResponse,tokenReflectionCount);
			//remove the random reflected value from the current response
			cleanCurrentResponse = cleanCurrentResponse.replace(token, ""); //TODO: handle potential issue in which the token already existed in the history - VERIFY

			if(DivinerFlags.DEBUG_FLAG == true) {
				System.out.println("=============================================");
				System.out.println("final original response:\n\n " + cleanOriginalResponse);
				System.out.println("=============================================");
				System.out.println("final current response:\n\n " + cleanCurrentResponse);
				System.out.println("=============================================");
			}
		}

		//remove timestamps
		//[0-9]{1,4}/[0-9]{1,2}/[0-9]{1,2} [0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2}
		
		cleanOriginalResponse = Pattern.compile("(\\d{1,2}:\\d{1,2}:\\d{1,2})").matcher(cleanOriginalResponse).replaceAll("");
		cleanCurrentResponse = Pattern.compile("(\\d{1,2}:\\d{1,2}:\\d{1,2})").matcher(cleanCurrentResponse).replaceAll("");
		
		
		//TODO:Replace the original reflected parameters in the response prior to the diff comparison
		//by comparing the clean original response to the clean current response

		/*
		ArrayList<String> originalResponseList = new ArrayList<>();
		originalResponseList.add(cleanOriginalResponse);
		Response_Manager ResponseManager = new Response_Manager(cleanCurrentResponse, originalResponseList, null);

		List<Diff> originalResponseReflectedValues = ResponseManager.getResponses(0).getDiffs();

		//Add to map only when there are differences in responses
		if (originalResponseReflectedValues.size() > 0) {
			for (Diff diff : originalResponseReflectedValues) {
				UnRelevantTag tag = new UnRelevantTag(diff.start, diff.modifiedValue, diff.end);
				reflectedTagList.add(tag);

			}
		}

		//if there are reflected values in the original response in the history - remove them prior to the comparison
		if(reflectedTagList.size()>0) {
			cleanOriginalResponse = UnRelevantInfo.removeUnRelevantData(cleanOriginalResponse, reflectedTagList, null); //remove from history response
		}

		//remove the reflected token from the current request
		if(cleanOriginalResponse.contains(token)) {
			//Houston, we have an issue 
			if(DivinerFlags.DEBUG_FLAG == true) {
				System.out.println("\nPotential bug - the token selected exists in the original reponse in history \n");
			}
		}
		 */

		similarity = GetResponsesSimilarity.getResponsesSimilarity(cleanOriginalResponse, cleanCurrentResponse);

		if(DivinerFlags.DEBUG_FLAG == true) {
			if(similarity < 100) {
				System.out.println("\n-------------------------Clean History Response " + target.getHistoryId() + ", similarity: " + similarity + "-------------------------\n");
				System.out.println(cleanOriginalResponse);
				System.out.println("\n-------------------------Current Clean Instance-------------------------\n");
				System.out.println(cleanCurrentResponse);
				System.out.println("\n--------------------------------------------------\n");

			}
		}

		//Found DIFF!!
		/*
		if (similarity < 100) {
			isDiff = true;
		}
		*/
		return similarity;
	}

	protected boolean isTokenFound(RecordHistory source, RecordHistory target, HttpMessage outputPage, String token,
			HtmlParameter suspectParam, TreeSet<HtmlParameter> params, FlowDocumentation flow, boolean writeMode)	{

		isTokenReflected = false;

		//Token was found in the response header or body
		if (token !="" && (outputPage.getResponseBody().toString().contains(token) || outputPage.getResponseHeader().toString().contains(token))) 
		{
			flow.setFoundInOutput(FOUND);
			this.token = token;
			if(DivinerFlags.DEBUG_FLAG == true) {

				System.out.println("---------------------------------------------------------------------------------------------------------------------------------------");
				System.out.println("FOUND!!!!! token " + token + " paramName: " + suspectParam.getName());
				System.out.println("source: " + source.getHttpMessage().getRequestHeader().getURI().toString());
				System.out.println("target: " + target.getHttpMessage().getRequestHeader().getURI().toString());
				System.out.println("Name of Param: " + suspectParam.getName());
				System.out.println("Output session: " + outputPage.getCookieParamsAsString());
			}
			isTokenReflected = FOUND;
		}

		return isTokenReflected;
	}


	public boolean isFound(){
		return isFound;
	}

	private void writeToDB(RecordHistory source, RecordHistory target, HttpMessage outputPage, String token,
			HtmlParameter suspectParam, TreeSet<HtmlParameter> params, FlowDocumentation flow, boolean writeMode, RESULT_TYPE outputPlugin) {
		try //Writing results to DB
		{
			if (writeMode) {
				long rowId = writeToDB(source, target, token, suspectParam, params, writeMode, diffInCleanResponse, tokenType, outputPlugin);

				/////////////////Clairvoyance write to DB!!!!!
				if (rowId != DONT_WRITE_FLOW) {	//We need to write the flow to database

					int sourceId = source.getHistoryId();
					String sourceURI = source.getHttpMessage().getRequestHeader().getURI().getPath() == null ? "/" : source.getHttpMessage().getRequestHeader().getURI().getPath();
					String targetURI = target.getHttpMessage().getRequestHeader().getURI().getPath() == null ? "/" : target.getHttpMessage().getRequestHeader().getURI().getPath();

					if (rowId != WRITE_DB_FLOW ) { //Only use this method to write if this is not a case of a database stored parameter - to avoid duplicate entries
						if (outputPlugin.equals(RESULT_TYPE.REFLECTION)) {
							if (isSourceTargetIdentical) {
								//source page source code
								CodeBehaviour.serverReflection(sourceURI, suspectParam.getName(), CodeBehaviour.getCodeId(), flow, DivinerTableFlow.DEFAULT_ORDER, sourceId, rowId);
							}
							//write results as Session
							else {								
								CodeBehaviour.sessionReflection(sourceURI, targetURI, suspectParam.getName(), CodeBehaviour.getCodeId(), flow, DivinerTableFlow.DEFAULT_ORDER, sourceId, rowId);
							}
						}
					}

				}

			}
		}

		catch(Exception e){ e.printStackTrace(); }
	}


	protected long writeToDB(RecordHistory source, RecordHistory target,  String token , HtmlParameter suspectParam, TreeSet<HtmlParameter> params, boolean writeMode, int diffPercent, TOKEN_TYPE tokenType, RESULT_TYPE outputPlugin) throws SQLException {

		long rowId = DONT_WRITE_FLOW;
		if(DivinerFlags.DEBUG_FLAG == true) {
			System.out.println("Source " + source.getHttpMessage().getRequestHeader().getURI().toString());
			System.out.println("Target " + target.getHttpMessage().getRequestHeader().getURI().toString());
			System.out.println("Writing result to DB: " + suspectParam.getName() +" " + diffPercent);
		}
		try{
			int sourceId = source.getHistoryId();
			int targetId = target.getHistoryId();
			HttpMessage sourceMsg = source.getHttpMessage();
			HttpMessage targetMsg = target.getHttpMessage();
			HttpRequestHeader sourceRequestHeader = sourceMsg.getRequestHeader();
			String sourcePath = sourceRequestHeader.getURI().getPath() == null ? "/" : sourceRequestHeader.getURI().getPath();
			String targetePath = targetMsg.getRequestHeader().getURI().getPath() == null ? "/" : targetMsg.getRequestHeader().getURI().getPath();
			String method = sourceRequestHeader.getMethod();

			int testType;


			for (HtmlParameter parameter : params)
			{

				long duplicateID = ZapHistoryDB.parameterTable.isDuplicate(sourcePath, parameter.getName(), method);
				if (duplicateID < 0)//param is not in DB
				{
					DivinerRecordParam paramRecord = ZapHistoryDB.parameterTable.insert(sourcePath, method, parameter.getName(), parameter.getValue());
					//Set the parameter ID that was FOUND in the Result table
					if (paramRecord.getName().equals(suspectParam.getName()))
					{

						//Set the effect type - exception or reflection or BOTH
						if (isException) {
							testType = isSourceTargetIdentical ? OUTPUT_TYPE.OUTPUT_EXCEPTION.ordinal() :  OUTPUT_TYPE.SESSION_EXCEPTION.ordinal();
							rowId = ZapHistoryDB.resultTable.insert(paramRecord.getParamId(),sourcePath, targetePath, testType, scenario.ordinal(), histMode.ordinal(), sourceId, targetId, diffPercent, tokenType.ordinal(), isTokenAppendMode, token, outputPlugin.ordinal());
						}

						if (isTokenReflected) {
							testType = isSourceTargetIdentical ? OUTPUT_TYPE.OUTPUT_REFLECTION.ordinal() :  OUTPUT_TYPE.SESSION_REFLECTION.ordinal();
							rowId = ZapHistoryDB.resultTable.insert(paramRecord.getParamId(),sourcePath, targetePath, testType, scenario.ordinal(), histMode.ordinal(), sourceId, targetId, diffPercent, tokenType.ordinal(), isTokenAppendMode, token, outputPlugin.ordinal());
						}
						
						if (isDiff) {
							testType = OUTPUT_TYPE.DIFF.ordinal();
							rowId = ZapHistoryDB.resultTable.insert(paramRecord.getParamId(),sourcePath, targetePath, testType, scenario.ordinal(), histMode.ordinal(), sourceId, targetId, diffPercent, tokenType.ordinal(), isTokenAppendMode, token, outputPlugin.ordinal());
						}
					}
				}
				else//param is already in DB
				{
					if (ZapHistoryDB.parameterTable.read(duplicateID).getName().equals(suspectParam.getName())) {
						if (isException) {
							testType = isSourceTargetIdentical ? OUTPUT_TYPE.OUTPUT_EXCEPTION.ordinal() :  OUTPUT_TYPE.SESSION_EXCEPTION.ordinal();
							rowId = ZapHistoryDB.resultTable.insert(duplicateID, sourcePath, targetePath, testType, scenario.ordinal(), histMode.ordinal(), sourceId, targetId, diffPercent, tokenType.ordinal(), isTokenAppendMode, token, outputPlugin.ordinal());
						}
						if (isTokenReflected) {
							testType = isSourceTargetIdentical ? OUTPUT_TYPE.OUTPUT_REFLECTION.ordinal() :  OUTPUT_TYPE.SESSION_REFLECTION.ordinal();
							rowId = ZapHistoryDB.resultTable.insert(duplicateID, sourcePath, targetePath, testType, scenario.ordinal(), histMode.ordinal(), sourceId, targetId, diffPercent, tokenType.ordinal(), isTokenAppendMode, token, outputPlugin.ordinal());
						}
						if (isDiff) {
							testType = OUTPUT_TYPE.DIFF.ordinal();
							rowId = ZapHistoryDB.resultTable.insert(duplicateID, sourcePath, targetePath, testType, scenario.ordinal(), histMode.ordinal(), sourceId, targetId, diffPercent, tokenType.ordinal(), isTokenAppendMode, token, outputPlugin.ordinal());
						}
					}
				}

			}
		}
		catch(URIException e) {
			e.printStackTrace();
		}
		return rowId;
	}


	public int getDiffPercentage() {
		return diffInCleanResponse;
	}

	public String getToken() {
		return token;
	}
}

package com.hacktics.diviner.database;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;

import org.parosproxy.paros.db.AbstractTable;

import com.hacktics.diviner.analyze.CodeBehaviour;
import com.hacktics.diviner.analyze.FlowDocumentation;

public class DivinerTableFlow extends AbstractTable{

	private static final String PAGENAME = "PAGE";
	private static final String FLOW = "FLOW";
	private static final String BEHAVIOUR = "BEHAVIOUR";
	private static final String PARAMNAME = "PARAMNAME";
	private static final String CODEID = "CODEID";
	private static final String FLOW_ORDER = "FLOWORDER";
	private static final String SOURCE_REQUEST_ID = "SOURCEREQ";
	private static final String RESULT_ID = "RESID";
	private static final String PROBABILITY = "PROBABILITY";
	private PreparedStatement psInsert1 = null;
	private PreparedStatement psRead = null;
	private PreparedStatement psRead2 = null;
	private PreparedStatement psDeleteFlow = null;
	private PreparedStatement psReadByParam = null;
	private PreparedStatement psFindBehaviour = null;

	
	public static final int DEFAULT_ORDER = -1;

	@Override
	protected void reconnect(Connection conn) throws SQLException {
		ResultSet rs = conn.getMetaData().getTables(null, null, "DIVINERFLOW", null);
		if ( ! rs.next()) {
			// Need to create the table
			// Alex: add varchar size limits (ZAP 1.4.1) - r29
			PreparedStatement stmt = conn.prepareStatement(
					"CREATE TABLE DIVINERFLOW (behaviourid bigint generated by default as identity (start with 1), behaviour int not null, page varchar(8192) not null, " +
					"paramName varchar(32768) not null, codeid int null, flow object, floworder int not null, sourcereq bigint not null, resid int not null, probability int not null )");
			stmt.execute();
		}
		rs.close();
		psInsert1 = conn.prepareStatement("INSERT INTO DIVINERFLOW (" + BEHAVIOUR + "," + PAGENAME + "," + PARAMNAME + "," + CODEID + "," + FLOW + "," + FLOW_ORDER  + "," + SOURCE_REQUEST_ID + "," + RESULT_ID + "," + PROBABILITY + ") VALUES (?, ?, ?, ? ,?, ?, ?, ?, ?)");
		psRead = conn.prepareStatement("SELECT flow FROM DIVINERFLOW WHERE " + PAGENAME + " LIKE ?");
		psRead2 = conn.prepareStatement("SELECT * FROM DIVINERFLOW WHERE " + PAGENAME + " LIKE ? ORDER BY " + FLOW_ORDER);
		psDeleteFlow = conn.prepareStatement("DELETE FROM DIVINERFLOW WHERE " + RESULT_ID + "= ?");
		psReadByParam = conn.prepareStatement("SELECT " + CODEID + " FROM DIVINERFLOW WHERE " + PAGENAME + " LIKE ? AND " + PARAMNAME + " LIKE ?");
		psFindBehaviour = conn.prepareStatement("SELECT * FROM DIVINERFLOW WHERE " + BEHAVIOUR + "= ? AND " + PAGENAME + " LIKE ?");
	} 

	public synchronized void insert(int behaviourId, String page, String paramName, int codeId, FlowDocumentation flow, int lineOrder, int sourceRequestID, long resultId, int probability) throws SQLException {
		psInsert1.setInt(1, behaviourId);
		psInsert1.setString(2, page);
		psInsert1.setString(3, paramName);
		psInsert1.setInt(4, codeId);
		psInsert1.setObject(5, flow, Types.JAVA_OBJECT);
		if (lineOrder == DEFAULT_ORDER) {
			psInsert1.setInt(6, CodeBehaviour.values()[behaviourId].getOrder());
		}
		else {
			psInsert1.setInt(6, lineOrder);
		}
		psInsert1.setInt(7, sourceRequestID);
		psInsert1.setLong(8, resultId);
		psInsert1.setInt(9, probability);
		psInsert1.executeUpdate();
	}

	//    public synchronized ArrayList<FlowDocumentation> getAll()  throws SQLException {
	//    	ArrayList<FlowDocumentation> result = new ArrayList<>();
	//    	
	//		ResultSet rs = psRead2.executeQuery();
	//		
	//		while (rs.next()) {
	//			result.add((FlowDocumentation)rs.getObject(1));
	//		}
	//		rs.close();
	//		return result;
	//    }

	
	//Will help to remove duplicate code lines
	public int getByParam(String pageName, String paramName, int newCodeId) throws SQLException {
		int result;
		psReadByParam.setString(1, pageName);
		psReadByParam.setString(2, paramName);
		ResultSet rs = psReadByParam.executeQuery();
		if (rs.next()) {
			result = rs.getInt(1);
		}
		else {
			result = newCodeId;
		}
		return result;
	}
	
	
	public boolean findBehabiour(String pageName, int behaviourId) {
		boolean result = false;
		try {
			psFindBehaviour.setInt(1, behaviourId);
			psFindBehaviour.setString(2, pageName);
			ResultSet rs = psFindBehaviour.executeQuery();
			if (rs.next()) {
				result = true;
			}
		}
		catch(SQLException e) {
			e.printStackTrace();
		}
		return result;
		
	}
	///////////End of functions that help to remove duplicate lines
	
	
	
	public  ArrayList<FlowDocumentation> read(String pageName) throws SQLException {
		ArrayList<FlowDocumentation> result = new ArrayList<FlowDocumentation>();
		psRead.setString(1, pageName);
		ResultSet rs = psRead.executeQuery();
		while (rs.next()){
			result.add((FlowDocumentation)rs.getObject(1));
		}
		rs.close();

		return result;

	}

	public void deleteFlow(long resultId) throws SQLException{
		psDeleteFlow.setLong(1, resultId);
		psDeleteFlow.execute();
		
	}
	public ArrayList<CodeLine> readSourceCode(String pageName) throws SQLException {
		ArrayList<CodeLine> result = new ArrayList<CodeLine>();
		psRead2.setString(1, pageName);
		ResultSet rs = psRead2.executeQuery();
		boolean duplicate;
		while (rs.next()) {
			//Don't add duplicates
			duplicate = false;
						for (CodeLine sourceCodeLine : result) {
							if (sourceCodeLine.getPageName().equals(rs.getString(PAGENAME)) && (sourceCodeLine.getSourceId() == rs.getInt(SOURCE_REQUEST_ID)) && (sourceCodeLine.getBehaviour() == rs.getInt(BEHAVIOUR)) && sourceCodeLine.getParamName().equals(rs.getString(PARAMNAME))) {
								duplicate = true;
								break;
							}
						}
			if (!duplicate) {
				result.add(new CodeLine(rs.getInt(BEHAVIOUR), rs.getString(PAGENAME), rs.getString(PARAMNAME), rs.getInt(CODEID), rs.getInt(SOURCE_REQUEST_ID), rs.getInt(PROBABILITY)));
			}
		}
		rs.close();

		return result;

	}


}
